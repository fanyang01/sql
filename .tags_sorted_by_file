!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
BUILD_DIR	Makefile	/^BUILD_DIR=.\/build$/;"	m
CC	Makefile	/^CC=gcc -Wall -I $(INCLUDE_DIR)$/;"	m
INCLUDE_DIR	Makefile	/^INCLUDE_DIR=.\/include$/;"	m
LIB_DIR	Makefile	/^LIB_DIR=.\/lib$/;"	m
SHELL	Makefile	/^SHELL=\/bin\/bash$/;"	m
SUBDIRS	Makefile	/^SUBDIRS := $(filter-out lib\/, \\$/;"	m
alloc_blk	allocator/alloc.c	/^handle_t alloc_blk(ALLOC * a, void *buf, size_t len)$/;"	f
dealloc_blk	allocator/alloc.c	/^int dealloc_blk(ALLOC * a, handle_t handle)$/;"	f
flt_find	allocator/alloc.c	/^handle_t flt_find(ALLOC * a, handle_t req, int *idx)$/;"	f
flt_idx	allocator/alloc.c	/^int flt_idx(handle_t atoms)$/;"	f
flt_remove	allocator/alloc.c	/^int flt_remove(ALLOC * a, int idx, handle_t prev, handle_t next)$/;"	f
free_blk	allocator/alloc.c	/^int free_blk(ALLOC * a, handle_t h, handle_t atoms)$/;"	f
init_allocator	allocator/alloc.c	/^int init_allocator(ALLOC * a, int fd, int oflag)$/;"	f
len2atom	allocator/alloc.c	/^handle_t len2atom(size_t len)$/;"	f
len_need	allocator/alloc.c	/^size_t len_need(size_t len)$/;"	f
list_setnext	allocator/alloc.c	/^int list_setnext(ALLOC * a, handle_t x, handle_t next)$/;"	f
list_setprev	allocator/alloc.c	/^int list_setprev(ALLOC * a, handle_t x, handle_t prev)$/;"	f
read_blk	allocator/alloc.c	/^void *read_blk(ALLOC * a, handle_t handle, void *buf, size_t * len)$/;"	f
realloc_blk	allocator/alloc.c	/^int realloc_blk(ALLOC * a, handle_t handle, void *buf, size_t len)$/;"	f
use_blk	allocator/alloc.c	/^int use_blk(ALLOC * a, handle_t h, void *buf, size_t len)$/;"	f
ALLOC	allocator/alloc.h	/^} ALLOC;$/;"	t	typeref:struct:__anon1
ATOM_LEN	allocator/alloc.h	68;"	d
CTBLK_LONG	allocator/alloc.h	74;"	d
CTBLK_MAXLONG	allocator/alloc.h	72;"	d
CTBLK_MAXSHORT	allocator/alloc.h	71;"	d
CTBLK_SHORT	allocator/alloc.h	73;"	d
FLT_LEN	allocator/alloc.h	69;"	d
FLT_SIZE	allocator/alloc.h	67;"	d
FRBLK_LONG	allocator/alloc.h	77;"	d
FRBLK_SINGLE	allocator/alloc.h	76;"	d
REBLK	allocator/alloc.h	75;"	d
_ALLOC_H	allocator/alloc.h	2;"	d
fd	allocator/alloc.h	/^	int fd;$/;"	m	struct:__anon1
flt	allocator/alloc.h	/^	handle_t flt[FLT_SIZE];$/;"	m	struct:__anon1
handle_t	allocator/alloc.h	/^typedef uint64_t handle_t;$/;"	t
main	allocator/alloc_test.c	/^int main(void)$/;"	f
buf_get	allocator/buf.c	/^void *buf_get(ALLOC * a, size_t len)$/;"	f
buf_put	allocator/buf.c	/^void buf_put(ALLOC * a, void *p)$/;"	f
b2hdl	common/common.c	/^handle_t b2hdl(void *buf)$/;"	f
b2uint16	common/common.c	/^uint16_t b2uint16(void *buf)$/;"	f
hdl2b	common/common.c	/^void *hdl2b(void *buf, handle_t h)$/;"	f
hdl2off	common/common.c	/^off_t hdl2off(handle_t handle)$/;"	f
off2hdl	common/common.c	/^handle_t off2hdl(off_t offset)$/;"	f
read_handle	common/common.c	/^handle_t read_handle(int fd, off_t offset)$/;"	f
uint16tob	common/common.c	/^void *uint16tob(void *buf, uint16_t i)$/;"	f
write_handle	common/common.c	/^int write_handle(int fd, handle_t h, off_t offset)$/;"	f
_COMMON_H	common/common.h	2;"	d
main	common/common_test.c	/^int main(void)$/;"	f
_alloc_db	db/db.c	/^DB *_alloc_db(size_t pathlen)$/;"	f
_free_db	db/db.c	/^void _free_db(DB * db)$/;"	f
closedb	db/db.c	/^void closedb(DB * db)$/;"	f
opendb	db/db.c	/^DB *opendb(const char *path, int oflag, ...)$/;"	f
DB	db/db.h	/^} DB;$/;"	t	typeref:struct:__anon11
_DB_H	db/db.h	2;"	d
a	db/db.h	/^	ALLOC a;$/;"	m	struct:__anon11
db_root	db/db.h	/^	handle_t db_root;	\/\/ value at handle #1$/;"	m	struct:__anon11
name	db/db.h	/^	char *name;$/;"	m	struct:__anon11
_errno_once	error/error.c	/^static pthread_once_t _errno_once = PTHREAD_ONCE_INIT;$/;"	v	file:
_errno_value	error/error.c	/^int *_errno_value(void)$/;"	f
_init_errno	error/error.c	/^static void _init_errno(void)$/;"	f	file:
_key	error/error.c	/^static pthread_key_t _key;$/;"	v	file:
ERR_BLKSIZE	error/xerror.h	19;"	d
ERR_BLKTAG	error/xerror.h	20;"	d
ERR_FSIZE	error/xerror.h	17;"	d
ERR_READLESS	error/xerror.h	18;"	d
_XERROR_H	error/xerror.h	2;"	d
err_strings	error/xerror.h	/^char *err_strings[] = {$/;"	v
perror	error/xerror.h	33;"	d
preserve_errno	error/xerror.h	11;"	d
strerror	error/xerror.h	34;"	d
xerrno	error/xerror.h	9;"	d
xperror	error/xerror.h	31;"	d
xstrerror	error/xerror.h	30;"	d
_GNU_SOURCE	file/file.c	2;"	d	file:
_POSIX_C_SOURCE	file/file.c	1;"	d	file:
alloc	file/file.c	/^int alloc(int fd, off_t offset, off_t len)$/;"	f
dealloc	file/file.c	/^int dealloc(int fd, off_t offset, off_t len)$/;"	f
fsize	file/file.c	/^off_t fsize(int fd)$/;"	f
readat	file/file.c	/^ssize_t readat(int fd, void *buf, size_t count, off_t offset)$/;"	f
writeat	file/file.c	/^ssize_t writeat(int fd, void *buf, size_t count, off_t offset)$/;"	f
_FILE_H	file/file.h	2;"	d
main	file/file_test.c	/^int main(void)$/;"	f
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
ALLOC	include/alloc.h	/^} ALLOC;$/;"	t	typeref:struct:__anon2
ATOM_LEN	include/alloc.h	68;"	d
CTBLK_LONG	include/alloc.h	74;"	d
CTBLK_MAXLONG	include/alloc.h	72;"	d
CTBLK_MAXSHORT	include/alloc.h	71;"	d
CTBLK_SHORT	include/alloc.h	73;"	d
FLT_LEN	include/alloc.h	69;"	d
FLT_SIZE	include/alloc.h	67;"	d
FRBLK_LONG	include/alloc.h	77;"	d
FRBLK_SINGLE	include/alloc.h	76;"	d
REBLK	include/alloc.h	75;"	d
_ALLOC_H	include/alloc.h	2;"	d
fd	include/alloc.h	/^	int fd;$/;"	m	struct:__anon2
flt	include/alloc.h	/^	handle_t flt[FLT_SIZE];$/;"	m	struct:__anon2
handle_t	include/alloc.h	/^typedef uint64_t handle_t;$/;"	t
_COMMON_H	include/common.h	2;"	d
DB	include/db.h	/^} DB;$/;"	t	typeref:struct:__anon6
_DB_H	include/db.h	2;"	d
a	include/db.h	/^	ALLOC a;$/;"	m	struct:__anon6
db_root	include/db.h	/^	handle_t db_root;	\/\/ value at handle #1$/;"	m	struct:__anon6
name	include/db.h	/^	char *name;$/;"	m	struct:__anon6
_FILE_H	include/file.h	2;"	d
_RECORD_H	include/record.h	2;"	d
cols	include/record.h	/^	colv_t *cols;$/;"	m	struct:__anon7
ncols	include/record.h	/^	int ncols;$/;"	m	struct:__anon7
record_t	include/record.h	/^} record_t;$/;"	t	typeref:struct:__anon7
INDICES_MAXLEN	include/table.h	11;"	d
INIT_TABLE	include/table.h	43;"	d
MAXCOLS	include/table.h	9;"	d
NAMELEN	include/table.h	8;"	d
SCOLS_MAXLEN	include/table.h	10;"	d
TABLE_MAXLEN	include/table.h	14;"	d
_TABLE_H	include/table.h	2;"	d
col_t	include/table.h	/^} col_t;$/;"	t	typeref:struct:__anon3
cols	include/table.h	/^	col_t *cols;$/;"	m	struct:__anon5
colv_t	include/table.h	/^} colv_t;$/;"	t	typeref:union:__anon4
f	include/table.h	/^	float f;$/;"	m	union:__anon4
head	include/table.h	/^	handle_t head;		\/\/ -> first record$/;"	m	struct:__anon5
hxroots	include/table.h	/^	handle_t hxroots;	\/\/ -> [root1, 0, root3, 0]$/;"	m	struct:__anon5
i	include/table.h	/^	int i;$/;"	m	union:__anon4
iname	include/table.h	/^	char *iname;$/;"	m	struct:__anon3
index	include/table.h	/^	handle_t index;$/;"	m	struct:__anon3
indices	include/table.h	/^	char *indices;		\/\/ "index1::index3:"$/;"	m	struct:__anon5
name	include/table.h	/^	char *name;		\/\/ name of table$/;"	m	struct:__anon5
name	include/table.h	/^	char *name;$/;"	m	struct:__anon3
ncols	include/table.h	/^	int ncols;$/;"	m	struct:__anon5
next	include/table.h	/^	handle_t next;		\/\/ next table metadata$/;"	m	struct:__anon5
s	include/table.h	/^	char *s;$/;"	m	union:__anon4
scols	include/table.h	/^	char *scols;		\/\/ "icol1:fcol2:scol3:icol4"$/;"	m	struct:__anon5
size	include/table.h	/^	int type, size;$/;"	m	struct:__anon3
sizes	include/table.h	/^	unsigned char *sizes;	\/\/ "[4, 4, 255, 4]" - never contains 0$/;"	m	struct:__anon5
table_t	include/table.h	/^} table_t;$/;"	t	typeref:struct:__anon5
type	include/table.h	/^	int type, size;$/;"	m	struct:__anon3
MAX_VARSTRLEN	include/type.h	33;"	d
TYPE_FLOAT	include/type.h	11;"	d
TYPE_FLOAT_SIZE	include/type.h	8;"	d
TYPE_INT	include/type.h	10;"	d
TYPE_INT_SIZE	include/type.h	7;"	d
TYPE_STRING	include/type.h	12;"	d
_SQL_TYPE_H	include/type.h	2;"	d
ERR_BLKSIZE	include/xerror.h	19;"	d
ERR_BLKTAG	include/xerror.h	20;"	d
ERR_FSIZE	include/xerror.h	17;"	d
ERR_READLESS	include/xerror.h	18;"	d
_XERROR_H	include/xerror.h	2;"	d
err_strings	include/xerror.h	/^char *err_strings[] = {$/;"	v
perror	include/xerror.h	33;"	d
preserve_errno	include/xerror.h	11;"	d
strerror	include/xerror.h	34;"	d
xerrno	include/xerror.h	9;"	d
xperror	include/xerror.h	31;"	d
xstrerror	include/xerror.h	30;"	d
CFLAGS	lib/Makefile	/^CFLAGS = -I ..\/include -Wall -lpthread$/;"	m
LIB	lib/Makefile	/^LIB=libsql.a$/;"	m
OBJ_FILES	lib/Makefile	/^OBJ_FILES := $(patsubst %.c, %.o, $(SRC_FILES))$/;"	m
SRC_FILES	lib/Makefile	/^SRC_FILES := $(wildcard *.c)$/;"	m
alloc_blk	lib/alloc.c	/^handle_t alloc_blk(ALLOC * a, void *buf, size_t len)$/;"	f
dealloc_blk	lib/alloc.c	/^int dealloc_blk(ALLOC * a, handle_t handle)$/;"	f
flt_find	lib/alloc.c	/^handle_t flt_find(ALLOC * a, handle_t req, int *idx)$/;"	f
flt_idx	lib/alloc.c	/^int flt_idx(handle_t atoms)$/;"	f
flt_remove	lib/alloc.c	/^int flt_remove(ALLOC * a, int idx, handle_t prev, handle_t next)$/;"	f
free_blk	lib/alloc.c	/^int free_blk(ALLOC * a, handle_t h, handle_t atoms)$/;"	f
init_allocator	lib/alloc.c	/^int init_allocator(ALLOC * a, int fd, int oflag)$/;"	f
len2atom	lib/alloc.c	/^handle_t len2atom(size_t len)$/;"	f
len_need	lib/alloc.c	/^size_t len_need(size_t len)$/;"	f
list_setnext	lib/alloc.c	/^int list_setnext(ALLOC * a, handle_t x, handle_t next)$/;"	f
list_setprev	lib/alloc.c	/^int list_setprev(ALLOC * a, handle_t x, handle_t prev)$/;"	f
read_blk	lib/alloc.c	/^void *read_blk(ALLOC * a, handle_t handle, void *buf, size_t * len)$/;"	f
realloc_blk	lib/alloc.c	/^int realloc_blk(ALLOC * a, handle_t handle, void *buf, size_t len)$/;"	f
use_blk	lib/alloc.c	/^int use_blk(ALLOC * a, handle_t h, void *buf, size_t len)$/;"	f
buf_get	lib/buf.c	/^void *buf_get(ALLOC * a, size_t len)$/;"	f
buf_put	lib/buf.c	/^void buf_put(ALLOC * a, void *p)$/;"	f
b2hdl	lib/common.c	/^handle_t b2hdl(void *buf)$/;"	f
b2uint16	lib/common.c	/^uint16_t b2uint16(void *buf)$/;"	f
hdl2b	lib/common.c	/^void *hdl2b(void *buf, handle_t h)$/;"	f
hdl2off	lib/common.c	/^off_t hdl2off(handle_t handle)$/;"	f
off2hdl	lib/common.c	/^handle_t off2hdl(off_t offset)$/;"	f
read_handle	lib/common.c	/^handle_t read_handle(int fd, off_t offset)$/;"	f
uint16tob	lib/common.c	/^void *uint16tob(void *buf, uint16_t i)$/;"	f
write_handle	lib/common.c	/^int write_handle(int fd, handle_t h, off_t offset)$/;"	f
_alloc_db	lib/db.c	/^DB *_alloc_db(size_t pathlen)$/;"	f
_free_db	lib/db.c	/^void _free_db(DB * db)$/;"	f
closedb	lib/db.c	/^void closedb(DB * db)$/;"	f
opendb	lib/db.c	/^DB *opendb(const char *path, int oflag, ...)$/;"	f
_errno_once	lib/error.c	/^static pthread_once_t _errno_once = PTHREAD_ONCE_INIT;$/;"	v	file:
_errno_value	lib/error.c	/^int *_errno_value(void)$/;"	f
_init_errno	lib/error.c	/^static void _init_errno(void)$/;"	f	file:
_key	lib/error.c	/^static pthread_key_t _key;$/;"	v	file:
_GNU_SOURCE	lib/file.c	2;"	d	file:
_POSIX_C_SOURCE	lib/file.c	1;"	d	file:
alloc	lib/file.c	/^int alloc(int fd, off_t offset, off_t len)$/;"	f
dealloc	lib/file.c	/^int dealloc(int fd, off_t offset, off_t len)$/;"	f
fsize	lib/file.c	/^off_t fsize(int fd)$/;"	f
readat	lib/file.c	/^ssize_t readat(int fd, void *buf, size_t count, off_t offset)$/;"	f
writeat	lib/file.c	/^ssize_t writeat(int fd, void *buf, size_t count, off_t offset)$/;"	f
_alloc_table	lib/table.c	/^table_t *_alloc_table(const char *name, int ncols)$/;"	f
_free_table	lib/table.c	/^void _free_table(table_t * t)$/;"	f
alloc_table	lib/table.c	/^handle_t alloc_table(ALLOC * a, table_t * t)$/;"	f
b2table	lib/table.c	/^void *b2table(void *buf, table_t * t)$/;"	f
read_table	lib/table.c	/^int read_table(ALLOC * a, handle_t h, table_t * t)$/;"	f
table2b	lib/table.c	/^void *table2b(void *buf, table_t * t)$/;"	f
tblsizeof	lib/table.c	/^size_t tblsizeof(table_t * t)$/;"	f
write_table	lib/table.c	/^int write_table(ALLOC * a, handle_t h, table_t * t)$/;"	f
b2float	lib/type.c	/^float b2float(void *buf)$/;"	f
b2int32	lib/type.c	/^int32_t b2int32(void *buf)$/;"	f
b2vstr	lib/type.c	/^void *b2vstr(void *buf, char *dst)$/;"	f
float2b	lib/type.c	/^void *float2b(void *buf, float f)$/;"	f
int32tob	lib/type.c	/^void *int32tob(void *buf, int32_t n)$/;"	f
str2b	lib/type.c	/^void *str2b(void *buf, size_t fixlen, const char *s)$/;"	f
vstr2b	lib/type.c	/^void *vstr2b(void *buf, const char *s)$/;"	f
vstrlen	lib/type.c	/^size_t vstrlen(void *buf)$/;"	f
vstrsizeof	lib/type.c	/^size_t vstrsizeof(const char *s)$/;"	f
_RECORD_H	record/record.h	2;"	d
cols	record/record.h	/^	colv_t *cols;$/;"	m	struct:__anon12
ncols	record/record.h	/^	int ncols;$/;"	m	struct:__anon12
record_t	record/record.h	/^} record_t;$/;"	t	typeref:struct:__anon12
CC	subdir.mk	/^CC=gcc -I ..\/include -Wall -L..\/lib -lpthread$/;"	m
SHELL	subdir.mk	/^SHELL=\/bin\/bash$/;"	m
SRC_FILE	subdir.mk	/^SRC_FILE := $(shell find . \\( \\! -name \\*_test.c \\) -a -name \\*.c -printf "%P ")$/;"	m
_alloc_table	table/table.c	/^table_t *_alloc_table(const char *name, int ncols)$/;"	f
_free_table	table/table.c	/^void _free_table(table_t * t)$/;"	f
alloc_table	table/table.c	/^handle_t alloc_table(ALLOC * a, table_t * t)$/;"	f
b2table	table/table.c	/^void *b2table(void *buf, table_t * t)$/;"	f
read_table	table/table.c	/^int read_table(ALLOC * a, handle_t h, table_t * t)$/;"	f
table2b	table/table.c	/^void *table2b(void *buf, table_t * t)$/;"	f
tblsizeof	table/table.c	/^size_t tblsizeof(table_t * t)$/;"	f
write_table	table/table.c	/^int write_table(ALLOC * a, handle_t h, table_t * t)$/;"	f
INDICES_MAXLEN	table/table.h	11;"	d
INIT_TABLE	table/table.h	43;"	d
MAXCOLS	table/table.h	9;"	d
NAMELEN	table/table.h	8;"	d
SCOLS_MAXLEN	table/table.h	10;"	d
TABLE_MAXLEN	table/table.h	14;"	d
_TABLE_H	table/table.h	2;"	d
col_t	table/table.h	/^} col_t;$/;"	t	typeref:struct:__anon8
cols	table/table.h	/^	col_t *cols;$/;"	m	struct:__anon10
colv_t	table/table.h	/^} colv_t;$/;"	t	typeref:union:__anon9
f	table/table.h	/^	float f;$/;"	m	union:__anon9
head	table/table.h	/^	handle_t head;		\/\/ -> first record$/;"	m	struct:__anon10
hxroots	table/table.h	/^	handle_t hxroots;	\/\/ -> [root1, 0, root3, 0]$/;"	m	struct:__anon10
i	table/table.h	/^	int i;$/;"	m	union:__anon9
iname	table/table.h	/^	char *iname;$/;"	m	struct:__anon8
index	table/table.h	/^	handle_t index;$/;"	m	struct:__anon8
indices	table/table.h	/^	char *indices;		\/\/ "index1::index3:"$/;"	m	struct:__anon10
name	table/table.h	/^	char *name;		\/\/ name of table$/;"	m	struct:__anon10
name	table/table.h	/^	char *name;$/;"	m	struct:__anon8
ncols	table/table.h	/^	int ncols;$/;"	m	struct:__anon10
next	table/table.h	/^	handle_t next;		\/\/ next table metadata$/;"	m	struct:__anon10
s	table/table.h	/^	char *s;$/;"	m	union:__anon9
scols	table/table.h	/^	char *scols;		\/\/ "icol1:fcol2:scol3:icol4"$/;"	m	struct:__anon10
size	table/table.h	/^	int type, size;$/;"	m	struct:__anon8
sizes	table/table.h	/^	unsigned char *sizes;	\/\/ "[4, 4, 255, 4]" - never contains 0$/;"	m	struct:__anon10
table_t	table/table.h	/^} table_t;$/;"	t	typeref:struct:__anon10
type	table/table.h	/^	int type, size;$/;"	m	struct:__anon8
equal	table/table_test.c	/^static int equal(table_t * t1, table_t * t2)$/;"	f	file:
main	table/table_test.c	/^int main(void)$/;"	f
b2float	type/type.c	/^float b2float(void *buf)$/;"	f
b2int32	type/type.c	/^int32_t b2int32(void *buf)$/;"	f
b2vstr	type/type.c	/^void *b2vstr(void *buf, char *dst)$/;"	f
float2b	type/type.c	/^void *float2b(void *buf, float f)$/;"	f
int32tob	type/type.c	/^void *int32tob(void *buf, int32_t n)$/;"	f
str2b	type/type.c	/^void *str2b(void *buf, size_t fixlen, const char *s)$/;"	f
vstr2b	type/type.c	/^void *vstr2b(void *buf, const char *s)$/;"	f
vstrlen	type/type.c	/^size_t vstrlen(void *buf)$/;"	f
vstrsizeof	type/type.c	/^size_t vstrsizeof(const char *s)$/;"	f
MAX_VARSTRLEN	type/type.h	33;"	d
TYPE_FLOAT	type/type.h	11;"	d
TYPE_FLOAT_SIZE	type/type.h	8;"	d
TYPE_INT	type/type.h	10;"	d
TYPE_INT_SIZE	type/type.h	7;"	d
TYPE_STRING	type/type.h	12;"	d
_SQL_TYPE_H	type/type.h	2;"	d
main	type/type_test.c	/^int main(void)$/;"	f
